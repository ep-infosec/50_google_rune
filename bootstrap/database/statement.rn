//  Copyright 2021 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use root
use filepath
use line
use block
use expr
use value

enum StateType {
  If
  Elseif
  Else
  Switch
  Case
  Default
  Do
  While
  For
  Assign
  Call
  Print  // print "Hello, World!\n"
  Println  // println "Hello, World!"
  Throw
  Return
  Generate
  Relation
  Appendcode
  Prependcode
  Use
  Import
  Importlib
  Importrpc
  Foreach
  Yield
  Ref  // These two are used by generators to manage reference counts.
  Unref
}

// Get the statement type keyword.
export func statementTypeGetKeyword(type: StateType) {
  switch type {
    case StateType.If {
      return "if"
    }
    case StateType.Elseif {
      return "else if"
    }
    case StateType.Else {
      return "else"
    }
    case StateType.Do {
      return "do"
    }
    case StateType.While {
      return "while"
    }
    case StateType.For {
      return "for"
    }
    case StateType.Foreach {
      return "foreach"
    }
    case StateType.Assign {
      return "assignment"
    }
    case StateType.Call {
      return "call"
    }
    case StateType.Print {
      return "print"
    }
    case StateType.Println {
      return "println"
    }
    case StateType.Throw {
      return "throw"
    }
    case StateType.Return {
      return "return"
    }
    case StateType.Switch {
      return "switch"
    }
    case StateType.Case {
      return "case"
    }
    case StateType.Default {
      return "default"
    }
    case StateType.Relation {
      return "relation"
    }
    case StateType.Generate {
      return "generate"
    }
    case StateType.Appendcode {
      return "appendcode"
    }
    case StateType.Prependcode {
      return "prependcode"
    }
    case StateType.Use {
      return "use"
    }
    case StateType.Import {
      return "import"
    }
    case StateType.Importlib {
      return "importlib"
    }
    case StateType.Importrpc {
      return "importrpc"
    }
    case StateType.Yield {
      return "yield"
    }
    case StateType.Ref {
      return "ref"
    }
    case StateType.Unref {
      return "unref"
    }
  }
}

// Represents all statements in Rune.
class Statement(self, block: Block, type: StateType, line: Line) {
  self.type = type
  self.line = line
  self.instantiated = false
  self.executed = false  // Only for relation statements, so we don't execute them twice.
  self.generated = false // This statement was generated by a generator or iterator.
  self.isFirstAssignment = false  // True if this is the first assignment to a variable, at top level.
  block.appendStatement(self)

  // Dump a statement to |text| without its sub-block.
  func dumpNoSubBlock(self, var text: string) {
    getRoot().indent(text)
    keyword = statementTypeGetKeyword(self.type)
    text += keyword
    expr = self.expr
    if !isnull(expr) {
      text += " "
      expr.dumpToString(text)
    }
    text += "\n"
  }

  // Dump the statement to the end of |text| for debugging purposes.
  func dumpToString(self, var text: string) {
    self.dumpNoSubBlock(text)
    block = self.subBlock
    if !isnull(block) {
      block!.dumpToString(text)
    }
  }

  // Dump the statement to stdout for debugging purposes.
  func dump(self) {
    text = ""
    self.dumpToString(text)
    println text
  }

  // Copy a statement's expression and sub-block to the new statement.
  func copyExprAndSubBlock(self, newStatement: Statement) {
    expr = self.expr
    if !isnull(expr) {
      newExpr = expr!.copy()
      newStatement.insertExpr(newExpr)
    }
    subBlock = self.subBlock
    if !isnull(subBlock) {
      newSubBlock = subBlock.copy()
      newStatement.insertSubBlock(newSubBlock)
    }
  }

  // Append a deep copy of the statement to destBlock.
  func appendCopy(self, destBlock: Block) -> Statement {
    if false {
      // Type hint for recursion.
      return self
    }
    newStatement = Statement(destBlock, self.type, self.line)
    self.copyExprAndSubBlock(newStatement)
    newStatement.instantiated = self.instantiated
    newStatement.executed = self.executed
    newStatement.generated = self.generated
    return newStatement
  }

  // Prepend a deep copy of the statement to destBlock.
  func prependCopy(self, destBlock: Block) -> Statement {
    newStatement = self.appendCopy(destBlock)
    // Move the statement to the start of the block.
    destBlock.removeStatement(newStatement)
    destBlock.insertStatement(newStatement)
    return newStatement
  }

  // Append a deep copy of the statement to destStatement's block, right after
  // |destStatement|.
  func appendCopyAfterStatement(self, destStatement: Statement) -> Statement {
    destBlock = destStatement.block!
    newStatement = self.appendCopy(destBlock)
    destBlock.removeStatement(newStatement)
    destBlock.insertAfterStatement(destStatement, newStatement)
    return newStatement
  }
}

relation DoublyLinked Block Statement cascade
relation OneToOne Root:"LastInitializer" Statement:"LastInitializer"

unittest basicStatementTest {
  filepath = Filepath.new("test_filepath", null(Filepath), false)
  line = Line(filepath, "Not a real line", 1u32)
  block = Block(line);
  statement =  Statement(block, StateType.Print, line)
  expr = Expr.newConstant(Value("Hello, World!\n"), line)
  statement.insertExpr(expr)
  statement.dump()
}
